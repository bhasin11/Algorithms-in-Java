# Algorithms-in-Java

<b>Algorithms, Data Structures</b> and <b>Coding Challenges</b> implemented in Java.

This repository is a collection of algorithms, data structures and coding challenges which I've implement over a period of time. The algorithms/solutions are tried to be implemented considering effecient Time and Space Complexity approaches. The solutions are well tested and, unless noted, are believe to be 100% correct.

# Data Structures in Java
In this section, you can find implementation of different Data Structures in JavaScript.

| Data Structure   | Implementation |
|------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| <b>Stack</b>  <br>  Methods Implemented: push(), pop(), peek(), isEmpty()               | [Click](https://github.com/bhasin11/Algorithms-in-JavaScript/blob/master/src/stack.js)|
| <b>Queue</b>  <br>  Methods Implemented: offer(), poll(), peek(), isEmpty()               | [Click](https://github.com/bhasin11/Algorithms-in-JavaScript/blob/master/src/queue.js)|
| <b>Circular Queue</b>  <br>  Methods Implemented: offer(), poll(), peek(), isEmpty()             | [Click](https://github.com/bhasin11/Algorithms-in-JavaScript/blob/master/src/circularQueue.js)|
| <b>Linked List</b>  <br>  Methods Implemented: insertFirst(), insertLast(), insertAt(), removeFirst(), removeLast(), removeAt(), displayAll(), contains(), indexOf(), clear(), get(), set(), size()               | [Click](https://github.com/bhasin11/Algorithms-in-JavaScript/blob/master/src/linkedList.js)|
| <b>Doubly Linked List</b>  <br>  Methods Implemented: insertFirst(), insertLast(), insertAt(), removeFirst(), removeLast(), removeAt(), displayAll(), contains(), indexOf(), clear(), get(), set(), size()               | [Click](https://github.com/bhasin11/Algorithms-in-JavaScript/blob/master/src/doublyLinkedList.js)|


# Coding Challenges in Java
In this section, you can find different coding challenges and their soluitons. 

| Description   | Solution | Difficulty |
|------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|------------------------------------------------------------------------|
| <b>Hamming Distance</b>  <br>  The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/hammingDistance.java)                               |Easy|
| <b>Number Complement</b>  <br>  Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.       | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/findComplement.java)                               |Easy|
| <b>Keyboard Row</b>  <br>  Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/findWords.java)                               |Easy|
| <b>Fizz Buzz</b>  <br>  Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/fizzBuzz.java)                               |Easy|
| <b>Reverse String</b>  <br>  Write a function that takes a string as input and returns the string reversed.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/reverseString.java)                               |Easy|
| <b>Island Perimeter</b>  <br>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/islandPerimeter.java)                               |Easy|
| <b>Nim Game</b>  <br>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/canWinNim.java)                               |Easy|
| <b>Max Consecutive Ones</b>  <br>Given a binary array, find the maximum number of consecutive 1s in this array.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/findMaxConsecutiveOnes.java)                               |Easy|
| <b>Single Number</b>  <br>Given an array of integers, every element appears twice except for one. Find that single one.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/singleNumber.java)                               |Easy|
| <b>Find All Numbers Disappeared in an Array</b>  <br>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/findDisappearedNumbers.java)                               |Easy|
| <b>Detect Capital</b>  <br>Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like "USA", All letters in this word are not capitals, like "leetcode", Only the first letter in this word is capital if it has more than one letter, like "Google". Otherwise, we define that this word doesn't use capitals in a right way.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/detectCapitalUse.java)                               |Easy|
| <b>Maximum Depth of Binary Tree</b>  <br>Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/maxDepth.java)                               |Easy|
| <b>Find the Difference</b>  <br>Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/findTheDifference.java)                               |Easy|
| <b>Sum of Two Integers</b>  <br>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.   | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/getSum.java)                               |Easy|
| <b>Invert Binary Tree</b>  <br>Given a binary tree, invert the tree. So the left child of a root becomes the right child and vice-versa.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/invertTree.java)                               |Easy|
| <b>Add Digits</b>  <br>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/addDigits.java)                               |Easy|
| <b>Construct the Rectangle</b>  <br>For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: 1. The area of the rectangular web page you designed must equal to the given target area. 2. The width W should not be larger than the length L, which means L >= W. 3. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/constructRectangle.java)                               |Easy|
| <b>Move Zeroes</b>  <br>Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/moveZeroes.java)                               |Easy|
| <b>Minimum Absolute Difference in BST</b>  <br>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/getMinimumDifference.java)                               |Easy|
| <b>Two Sum II - Input array is sorted</b>  <br>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/twoSum2.java)                               |Easy|
| <b>Assign Cookies</b>  <br>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Note: You may assume the greed factor is always positive. You cannot assign more than one cookie to one child.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/findContentChildren.java)                               |Easy|
| <b>Minimum Moves to Equal Array Elements</b>  <br>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/minMoves.java)                               |Easy|
| <b>Ransom Note</b>  <br>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/canConstruct.java)                               |Easy|
| <b>Sum of Left Leaves</b>  <br>Find the sum of all left leaves in a given binary tree.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/sumOfLeftLeaves.java)                               |Easy|
| <b>Intersection of Two Arrays</b>  <br>Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/intersection.java)                               |Easy|
| <b>First Unique Character in a String</b>  <br>Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1. Example: s = "leetcode" return 0. Example: s = "loveleetcode", return 2. Note: You may assume the string contain only lowercase letters.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/firstUniqChar.java)                               |Easy|
| <b>Excel Sheet Column Number</b>  <br>Given a column title as appear in an Excel sheet, return its corresponding column number. For example: A -> 1, B -> 2, C -> 3 ... Z -> 26, AA -> 27, AB -> 28               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/titleToNumber.java)                               |Easy|
| <b>Delete Node in a Linked List</b>  <br>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/deleteNode.java)                               |Easy|
| <b>Same Tree</b>  <br>Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isSameTree.java)                               |Easy|
| <b>Base 7</b>  <br>Given an integer, return its base 7 string representation. Example 1: Input: 100 Output: "202" Example 2: Input: -7 Output: "-10"               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/convertToBase7.java)                               |Easy|
| <b>Majority Element</b>  <br>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/majorityElement.java)                               |Easy|
| <b>Valid Anagram</b>  <br>Given two strings s and t, write a function to determine if t is an anagram of s. Example, s = "anagram", t = "nagaram", return true. Example, s = "rat", t = "car", return false. Note: You may assume the string contains only lowercase alphabets.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isAnagram.java)                               |Easy|
| <b>Longest Palindrome</b>  <br>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example "Aa" is not considered a palindrome here.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/longestPalindrome.java)                               |Easy|
| <b>Binary Watch</b>  <br>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/readBinaryWatch.java)                               |Easy|
| <b>Contains Duplicate</b>  <br>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/containsDuplicate.java)                               |Easy|
| <b>Roman to Integer</b>  <br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/romanToInt.java)                               |Easy|
| <b>Reverse String II</b>  <br>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/reverseStr.java)                               |Easy|
| <b>Intersection of Two Arrays II</b>  <br>Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/intersect.java)                               |Easy|
| <b>Missing Number</b>  <br>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. For example, Given nums = [0, 1, 3] return 2.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/missingNumber.java)                               |Easy|
| <b>Number of Boomerangs</b>  <br>Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example: Input: [[0,0],[1,0],[2,0]] Output: 2 Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/numberOfBoomerangs.java)                               |Easy|
| <b>Diameter of Binary Tree</b>  <br>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/diameterOfBinaryTree.java)                               |Easy|
| <b>Convert Sorted Array to Binary Search Tree</b>  <br>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/sortedArrayToBST.java)                               |Easy|
| <b>Best Time to Buy and Sell Stock</b>  <br>Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/maxProfit.java)                               |Easy|
| <b>Best Time to Buy and Sell Stock II</b>  <br>Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/maxProfit2.java)                               |Easy|
| <b>Best Time to Buy and Sell Stock II</b>  <br>Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/maxProfit2.java)                               |Easy|
| <b>Happy Number</b>  <br>Write an algorithm to determine if a number is "happy". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isHappy.java)                               |Easy|
| <b>Power of Three</b>  <br>Given an integer, write a function to determine if it is a power of three.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isPowerOfThree.java)                               |Easy|
| <b>Power of Two</b>  <br>Given an integer, write a function to determine if it is a power of two.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isPowerOfTwo.java)                               |Easy|
| <b>Remove Duplicates from Sorted List</b>  <br>Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1->1->2, return 1->2. Given 1->1->2->3->3, return 1->2->3.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/deleteDuplicates.java)                               |Easy|
| <b>Search Insert Position</b>  <br>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples. [1,3,5,6], 5 → 2; [1,3,5,6], 2 → 1; [1,3,5,6], 7 → 4; [1,3,5,6], 0 → 0;              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/searchInsert.java)                               |Easy|
| <b>Climbing Stairs</b>  <br>You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/climbStairs.java)                               |Easy|
| <b>Maximum Subarray</b>  <br>Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/maxSubArray.java)                               |Easy|
| <b>Path Sum III</b>  <br>You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/pathSum.java)                               |Easy|
| <b>Number of 1 Bits</b>  <br>Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/hammingWeight.java)                               |Easy|
| <b>Binary Tree Level Order Traversal II</b>  <br>Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/levelOrderBottom.java)                               |Easy|
| <b>Ugly Number</b>  <br>Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isUgly.java)                               |Easy|
| <b>Find Mode in Binary Search Tree</b>  <br>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. If a tree has more than one mode, you can return them in any order.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/findMode.java)                               |Easy|
| <b>Merge Two Sorted Lists</b>  <br>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/mergeTwoLists.java)                               |Easy|
| <b>Lowest Common Ancestor of a Binary Search Tree</b>  <br>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/lowestCommonAncestor.java)                               |Easy|
| <b>Repeated Substring Pattern</b>  <br>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.               | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/repeatedSubstringPattern.java)                               |Easy|
| <b>House Robber</b>  <br>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/rob.java)                               |Easy|
| <b>Power of Four</b>  <br>Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example: Given num = 16, return true. Given num = 5, return false.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isPowerOfFour.java)                               |Easy|
| <b>Reverse Vowels of a String</b>  <br>Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Given s = "hello", return "holle". Example 2: Given s = "leetcode", return "leotcede".              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/reverseVowels.java)                               |Easy|
| <b>Remove Element</b>  <br>Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example: Given input array nums = [3,2,2,3], val = 3. Your function should return length = 2, with the first two elements of nums being 2.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/removeElement.java)                               |Easy|
| <b>Valid Perfect Square</b>  <br>Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: Input: 16 Returns: True. Example 2: Input: 14 Returns: False              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isPerfectSquare.java)                               |Easy|
| <b>Symmetric Tree</b>  <br>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/isSymmetric.java)                               |Easy|
| <b>Plus One</b>  <br>Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list.              | [Click](https://github.com/bhasin11/Algorithms-in-Java/blob/master/src/plusOne.java)                               |Easy|
